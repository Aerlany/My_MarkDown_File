

# c语言学习

## 一、c程序结构

C 程序主要包括以下部分：

```
预处理器指令
函数
变量
语句 & 表达式
注释
```

**关键字**

| 关键字   | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| auto     | 声明自动变量                                                 |
| break    | 跳出当前循环                                                 |
| case     | 开关语句分支                                                 |
| char     | 声明字符型变量或函数返回值类型                               |
| const    | 定义常量，如果一个变量被 const 修饰，那么它的值就不能再被改变 |
| continue | 结束当前循环，开始下一轮循环                                 |
| default  | switch语句中的"其它"分支                                     |
| do       | 循环语句的循环体                                             |
| double   | 声明双精度浮点型变量或函数返回值类型                         |
| else     | 条件语句否定分支（与 if 连用）                               |
| enum     | 声明枚举类型                                                 |
| extern   | 声明变量或函数是在其它文件或本文件的其他位置定义             |
| float    | 声明浮点型变量或函数返回值类型                               |
| for      | 一种循环语句                                                 |
| goto     | 无条件跳转语句                                               |
| if       | 条件语句                                                     |
| int      | 声明整型变量或函数                                           |
| long     | 声明长整型变量或函数返回值类型                               |
| register | 声明寄存器变量                                               |
| return   | 子程序返回语句（可以带参数，也可不带参数）                   |
| short    | 声明短整型变量或函数                                         |
| signed   | 声明有符号类型变量或函数                                     |
| sizeof   | 计算数据类型或变量长度（即所占字节数）                       |
| static   | 声明静态变量                                                 |
| struct   | 声明结构体类型                                               |
| switch   | 用于开关语句                                                 |
| typedef  | 用以给数据类型取别名                                         |
| unsigned | 声明无符号类型变量或函数                                     |
| union    | 声明共用体类型                                               |
| void     | 声明函数无返回值或无参数，声明无类型指针                     |
| volatile | 说明变量在程序执行中可被隐含地改变                           |
| while    | 循环语句的循环条件                                           |

C99 新增关键字

```
_Bool	_Complex	_Imaginary	inline	restrict
```

C11 新增关键字

```
_Alignas	_Alignof	_Atomic	_Generic	_Noreturn
_Static_assert	_Thread_local
```

## 二、c数据类型

**整数类型**

| 类型           | 储存大小    | 值范围                                               |
| -------------- | :---------- | ---------------------------------------------------- |
| char           | 1字节       | -128 到127  或  0 到 255                             |
| unsigned char  | 1字节       | 0 到 255                                             |
| signed char    | 1字节       | -128 到 127                                          |
| int            | 2 或 4字节  | -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 |
| unsigned int   | 2 或 4 字节 | 0 到 65,535 或 0 到 4,294,967,295                    |
| short          | 2 字节      | -32,768 到 32,767                                    |
| unsigned short | 2 字节      | 0 到 65,535                                          |
| long           | 4 字节      | -2,147,483,648 到 2,147,483,647                      |
| unsigned long  | 4 字节      | 0 到 4,294,967,295                                   |

```c
#include <stdio.h>
#include <limits.h>
 
int main()
{
   printf("int 存储大小 : %lu \n", sizeof(int));
   
   return 0;
}
//%lu 为 32 位无符号整数
```

**浮点类型**

| 类型        | 储存大小 | 值范围                 | 精度        |
| ----------- | -------- | ---------------------- | ----------- |
| float       | 4字节    | 1.2E-38 到 3.4E+38     | 6 位有效位  |
| double      | 8字节    | 2.3E-308 到 1.7E+308   | 15 位有效位 |
| long double | 16 字节  | 3.4E-4932 到 1.1E+4932 | 19 位有效位 |

```c
#include <stdio.h>
#include <float.h>
 
int main()
{
   printf("float 存储最大字节数 : %lu \n", sizeof(float));
   printf("float 最小值: %E\n", FLT_MIN );
   printf("float 最大值: %E\n", FLT_MAX );
   printf("精度值: %d\n", FLT_DIG );
   
   return 0;
}
//%E 为以指数形式输出单、双精度实数
```

**void 类型**

void 类型指定没有可用的值。它通常用于以下三种情况下：

| 类型与描述        | C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。                       例如 void exit (int status); |
| ----------------- | ------------------------------------------------------------ |
| **函数参数为空**  | C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。                                                    例如 **int rand(void);** |
| **指针指向 void** | 类型为 void * 的指针代表对象的地址，而不是类型。                                                                                例如，内存分配函数 **void \*malloc( size_t size );** 返回指向 void 的指针，可以转换为任何数据类型。 |



## 三、C 变量

变量其实只不过是程序可操作的存储区的名称

| 类型   | 描述                                                         |
| :----- | :----------------------------------------------------------- |
| char   | 通常是一个字节（八位）, 这是一个整数类型。                   |
| int    | 整型，4 个字节，取值范围 -2147483648 到 2147483647。         |
| float  | 单精度浮点值。单精度是这样的格式，1位符号，8位指数，23位小数。![img](https://www.runoob.com/wp-content/uploads/2014/09/v2-749cc641eb4d5dafd085e8c23f8826aa_hd.png) |
| double | 双精度浮点值。双精度是1位符号，11位指数，52位小数。![img](https://www.runoob.com/wp-content/uploads/2014/09/v2-48240f0e1e0dd33ec89100cbe2d30707_hd.png) |
| void   | 表示类型的缺失。                                             |

C 语言也允许定义各种其他类型的变量，比如枚举、指针、数组、结构、共用体等



**C 中的变量声明**

变量声明向编译器保证变量以指定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。

变量的声明有两种情况：

- 1、一种是需要建立存储空间的。例如：int a 在声明的时候就已经建立了存储空间。
- 2、另一种是不需要建立存储空间的，通过使用extern关键字声明变量名而不定义它。 例如：extern int a 其中变量 a 可以在别的文件中定义的。
- 除非有extern关键字，否则都是变量的定义。

```c
extern int i; //声明，不是定义
int i; //声明，也是定义
```

**实例（在函数体中对全局变量进行赋值）**

```c
#include <stdio.h>
 
// 函数外定义变量 x 和 y
int x;
int y;
int addtwonum()
{
    // 函数内声明变量 x 和 y 为外部变量
    extern int x;
    extern int y;
    // 给外部变量（全局变量）x 和 y 赋值
    x = 1;
    y = 2;
    return x+y;
}
 
int main()
{
    int result;
    // 调用函数 addtwonum
    result = addtwonum();
    
    printf("result 为: %d",result);
    return 0;
}
```

```c
result 为: 3
```



**C 中的左值（Lvalues）和右值（Rvalues）**

C 中有两种类型的表达式：

左值（lvalue）：指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。
右值（rvalue）：术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。



## 四、c常量

常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做**字面量**。

常量可以是任何的基本数据类型，比如整数常量、浮点常量、字符常量，或字符串字面值，也有枚举常量。

**常量**就像是常规的变量，只不过常量的值在定义后不能进行修改。

**整数常量**

整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。

整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。

下面列举几个整数常量的实例：

```
212         /* 合法的 */
215u        /* 合法的 */
0xFeeL      /* 合法的 */
078         /* 非法的：8 不是八进制的数字 */
032UU       /* 非法的：不能重复后缀 */
```

以下是各种类型的整数常量的实例：

```
85         /* 十进制 */
0213       /* 八进制 */
0x4b       /* 十六进制 */
30         /* 整数 */
30u        /* 无符号整数 */
30l        /* 长整数 */
30ul       /* 无符号长整数 */
```

**浮点常量**

浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。

当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。

下面列举几个浮点常量的实例：

```
3.14159       /* 合法的 */
314159E-5L    /* 合法的 */
510E          /* 非法的：不完整的指数 */
210f          /* 非法的：没有小数或指数 */
.e55          /* 非法的：缺少整数或分数 */
```

**字符常量**

字符常量是括在单引号中，例如，'x' 可以存储在 **char** 类型的简单变量中。

字符常量可以是一个普通的字符（例如 'x'）、一个转义序列（例如 '\t'），或一个通用的字符（例如 '\u02C0'）。

在 C 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\n）或制表符（\t）等。下表列出了一些这样的转义序列码：

| 转义序列   | 含义                       |
| :--------- | :------------------------- |
| \\         | \ 字符                     |
| \'         | ' 字符                     |
| \"         | " 字符                     |
| \?         | ? 字符                     |
| \a         | 警报铃声                   |
| \b         | 退格键                     |
| \f         | 换页符                     |
| \n         | 换行符                     |
| \r         | 回车                       |
| \t         | 水平制表符                 |
| \v         | 垂直制表符                 |
| \ooo       | 一到三位的八进制数         |
| \xhh . . . | 一个或多个数字的十六进制数 |

**字符串常量**

字符串字面值或常量是括在双引号 "" 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。

您可以使用空格做分隔符，把一个很长的字符串常量进行分行。

下面的实例显示了一些字符串常量。下面这三种形式所显示的字符串是相同的。

```c
"hello, dear"

"hello, \

dear"

"hello, " "d" "ear"
```

**定义常量**

在 C 中，有两种简单的定义常量的方式：

1. 使用 **#define** 预处理器。
2. 使用 **const** 关键字。

**#define 预处理器**

下面是使用 #define 预处理器定义常量的形式：

```
#define identifier value
```

具体请看下面的实例：

**实例**

```c
#include <stdio.h>
 
#define LENGTH 10   
#define WIDTH  5
#define NEWLINE '\n'
 
int main()
{
 
   int area;  
  
   area = LENGTH * WIDTH;
   printf("value of area : %d", area);
   printf("%c", NEWLINE);
 
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
value of area : 50
```

**const 关键字**

您可以使用 **const** 前缀声明指定类型的常量，如下所示：

```
const type variable = value;
```

![img](https://www.runoob.com/wp-content/uploads/2014/09/c-const-2021-01-15.png)

const 声明常量要在一个语句内完成：

![img](https://www.runoob.com/wp-content/uploads/2014/09/c-const-2021-01-15-2.png)

具体请看下面的实例：

**实例**

```c
#include <stdio.h>
 
int main()
{
   const int  LENGTH = 10;
   const int  WIDTH  = 5;
   const char NEWLINE = '\n';
   int area;  
   
   area = LENGTH * WIDTH;
   printf("value of area : %d", area);
   printf("%c", NEWLINE);
 
   return 0;
}
```

当上面S的代码被编译和执行时，它会产生下列结果：

```
value of area : 50
```

请注意，把常量定义为大写字母形式

## 五、C 存储类

存储类定义 C 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。

**auto 存储类**

auto 存储类是所有局部变量默认的存储类。

```c
{
   int mount;
   auto int month;
}
```

上面的实例定义了两个带有相同存储类的变量，auto 只能用在函数内，即 auto 只能修饰局部变量

register 存储类
register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个字），且不能对它应用一元的 '&' 运算符（因为它没有内存位置）。

```c
{
   register int  miles;
}
```

寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 'register' 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制

**static 存储类**

**static** 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。

static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。

全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件中。

以下实例演示了 static 修饰全局变量和局部变量的应用：

```c
#include <stdio.h>

/*函数声明*/
void function1(void);

/*全局变量-static是默认的*/
static int count = 10;

int main() {
  while (count--) {
    function1();
  }
  return 0;
}

void function1(void) {
  /* 'thingy' 是 'func1' 的局部变量 - 只初始化一次
   * 每次调用函数 'func1' 'thingy' 值不会被重置。
   */
  static int thingy = 5;
  thingy++;
  printf("count 的值是：%d \t thingy 的值是：%d\n", count, thingy);
}
```

**结果**

```sh
count 的值是：9 	 thingy 的值是：6
count 的值是：8 	 thingy 的值是：7
count 的值是：7 	 thingy 的值是：8
count 的值是：6 	 thingy 的值是：9
count 的值是：5 	 thingy 的值是：10
count 的值是：4 	 thingy 的值是：11
count 的值是：3 	 thingy 的值是：12
count 的值是：2 	 thingy 的值是：13
count 的值是：1 	 thingy 的值是：14
count 的值是：0 	 thingy 的值是：15
```

**注意：**

对于全局变量：全局变量默认都是由**static**修饰的

对于局部变量：由**static**修饰的局部变量只会初始化一次



**extern 存储类**

**extern** 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。

当您使用 **extern** 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。

当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 *extern* 来得到已定义的变量或函数的引用。

可以这么理解，*extern* 是用来在另一个文件中声明一个全局变量或函数。

extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候

**extern**修饰的函数或变量可以两个或多个文件共享

```c
//在main.c
#include <stdio.h>

int count;
extern void function1();

int main() {
  count = 5;
  function1();
}

```

```c
//在support.c

#include <stdio.h>

extern int count;
void function1() { printf("count = %d", count); }
```





## 六、C 运算符

**算术运算符**

下表显示了 C 语言支持的所有算术运算符。假设变量 **A** 的值为 10，变量 **B** 的值为 20，则：

| 运算符 | 描述                             | 实例             |
| :----- | :------------------------------- | :--------------- |
| +      | 把两个操作数相加                 | A + B 将得到 30  |
| -      | 从第一个操作数中减去第二个操作数 | A - B 将得到 -10 |
| *      | 把两个操作数相乘                 | A * B 将得到 200 |
| /      | 分子除以分母                     | B / A 将得到 2   |
| %      | 取模运算符，整除后的余数         | B % A 将得到 0   |
| ++     | 自增运算符，整数值增加 1         | A++ 将得到 11    |
| --     | 自减运算符，整数值减少 1         | A-- 将得到 9     |



**关系运算符**

下表显示了 C 语言支持的所有关系运算符。假设变量 **A** 的值为 10，变量 **B** 的值为 20，则：

| 运算符 | 描述                                                         | 实例            |
| :----- | :----------------------------------------------------------- | :-------------- |
| ==     | 检查两个操作数的值是否相等，如果相等则条件为真。             | (A == B) 为假。 |
| !=     | 检查两个操作数的值是否相等，如果不相等则条件为真。           | (A != B) 为真。 |
| >      | 检查左操作数的值是否大于右操作数的值，如果是则条件为真。     | (A > B) 为假。  |
| <      | 检查左操作数的值是否小于右操作数的值，如果是则条件为真。     | (A < B) 为真。  |
| >=     | 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 | (A >= B) 为假。 |
| <=     | 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 | (A <= B) 为真。 |



**逻辑运算符**

下表显示了 C 语言支持的所有关系逻辑运算符。假设变量 **A** 的值为 1，变量 **B** 的值为 0，则：

| 运算符 | 描述                                                         | 实例              |
| :----- | :----------------------------------------------------------- | :---------------- |
| &&     | 称为逻辑与运算符。如果两个操作数都非零，则条件为真。         | (A && B) 为假。   |
| \|\|   | 称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。 | (A \|\| B) 为真。 |
| !      | 称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。 | !(A && B) 为真。  |

**位运算符**

位运算符作用于位，并逐位执行操作。&、 | 和 ^ 的真值表如下所示：

| p    | q    | p & q | p \| q | p ^ q |
| :--- | :--- | :---- | :----- | :---- |
| 0    | 0    | 0     | 0      | 0     |
| 0    | 1    | 0     | 1      | 1     |
| 1    | 1    | 1     | 1      | 0     |
| 1    | 0    | 0     | 1      | 1     |

下表显示了 C 语言支持的位运算符。假设变量 **A** 的值为 60，变量 **B** 的值为 13，则：

| 运算符 | 描述                                                         | 实例                                                         |
| :----- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| &      | 按位与操作，按二进制位进行"与"运算。运算规则：`0&0=0;    0&1=0;     1&0=0;      1&1=1;` | (A & B) 将得到 12，即为 0000 1100                            |
| \|     | 按位或运算符，按二进制位进行"或"运算。运算规则：`0|0=0;    0|1=1;    1|0=1;     1|1=1;` | (A \| B) 将得到 61，即为 0011 1101                           |
| ^      | 异或运算符，按二进制位进行"异或"运算。运算规则：`0^0=0;    0^1=1;    1^0=1;   1^1=0;` | (A ^ B) 将得到 49，即为 0011 0001                            |
| ~      | 取反运算符，按二进制位进行"取反"运算。运算规则：`~1=-2;    ~0=-1;` | (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 |
| <<     | 二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。 | A << 2 将得到 240，即为 1111 0000                            |
| >>     | 二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。 | A >> 2 将得到 15，即为 0000 1111                             |

**赋值运算符**

下表列出了 C 语言支持的赋值运算符：

| 运算符 | 描述                                                         | 实例                            |
| :----- | :----------------------------------------------------------- | :------------------------------ |
| =      | 简单的赋值运算符，把右边操作数的值赋给左边操作数             | C = A + B 将把 A + B 的值赋给 C |
| +=     | 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 | C += A 相当于 C = C + A         |
| -=     | 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 | C -= A 相当于 C = C - A         |
| *=     | 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 | C *= A 相当于 C = C * A         |
| /=     | 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 | C /= A 相当于 C = C / A         |
| %=     | 求模且赋值运算符，求两个操作数的模赋值给左边操作数           | C %= A 相当于 C = C % A         |
| <<=    | 左移且赋值运算符                                             | C <<= 2 等同于 C = C << 2       |
| >>=    | 右移且赋值运算符                                             | C >>= 2 等同于 C = C >> 2       |
| &=     | 按位与且赋值运算符                                           | C &= 2 等同于 C = C & 2         |
| ^=     | 按位异或且赋值运算符                                         | C ^= 2 等同于 C = C ^ 2         |
| \|=    | 按位或且赋值运算符                                           | C \|= 2 等同于 C = C \| 2       |



**杂项运算符 ↦ sizeof & 三元**

下表列出了 C 语言支持的其他一些重要的运算符，包括 **sizeof** 和 **? :**。

| 运算符   | 描述             | 实例                                 |
| :------- | :--------------- | :----------------------------------- |
| sizeof() | 返回变量的大小。 | sizeof(a) 将返回 4，其中 a 是整数。  |
| &        | 返回变量的地址。 | &a; 将给出变量的实际地址。           |
| *        | 指向一个变量。   | *a; 将指向一个变量。                 |
| ? :      | 条件表达式       | 如果条件为真 ? 则值为 X : 否则值为 Y |



**C** **中的运算符优先级**

运算符的优先级确定表达式中项的组合。这会影响到一个表达式如何计算。某些运算符比其他运算符有更高的优先级，例如，乘除运算符具有比加减运算符更高的优先级。

例如 x = 7 + 3 * 2，在这里，x 被赋值为 13，而不是 20，因为运算符 * 具有比 + 更高的优先级，所以首先计算乘法 3*2，然后再加上 7。

下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。

| 类别       | 运算符                            | 结合性   |
| :--------- | :-------------------------------- | :------- |
| 后缀       | () [] -> . ++ - -                 | 从左到右 |
| 一元       | + - ! ~ ++ - - (type)* & sizeof   | 从右到左 |
| 乘除       | * / %                             | 从左到右 |
| 加减       | + -                               | 从左到右 |
| 移位       | << >>                             | 从左到右 |
| 关系       | < <= > >=                         | 从左到右 |
| 相等       | == !=                             | 从左到右 |
| 位与 AND   | &                                 | 从左到右 |
| 位异或 XOR | ^                                 | 从左到右 |
| 位或 OR    | \|                                | 从左到右 |
| 逻辑与 AND | &&                                | 从左到右 |
| 逻辑或 OR  | \|\|                              | 从左到右 |
| 条件       | ?:                                | 从右到左 |
| 赋值       | = += -= *= /= %=>>= <<= &= ^= \|= | 从右到左 |
| 逗号       | ,                                 | 从左到右 |



## 七、C判断

C 语言把任何**非零**和**非空**的值假定为 **true**，把**零**或 **null** 假定为 **false**。

------

**C if 语句**

一个 **if 语句** 由一个布尔表达式后跟一个或多个语句组成。

C 语言中 **if** 语句的语法：

```c
if(boolean_expression)
{
   /* 如果布尔表达式为真将执行的语句 */
}
```

```c
if(boolean_expression)
{
   /* 如果布尔表达式为真将执行的语句 */
}
else
{
   /* 如果布尔表达式为假将执行的语句 */
}
```

如果布尔表达式为 **true**，则执行 **if** 块内的代码。如果布尔表达式为 **false**，则执行 **else** 块内的代码。



------

**C switch 语句**

一个 **switch** 语句允许测试一个变量等于多个值时的情况。每个值称为一个 case，且被测试的变量会对每个 **switch case** 进行检查。

C 语言中 **switch** 语句的语法：

```c
switch(expression){
    case constant-expression  :
       statement(s);
       break; /* 可选的 */
    case constant-expression  :
       statement(s);
       break; /* 可选的 */
  
    /* 您可以有任意数量的 case 语句 */
    default : /* 可选的 */
       statement(s);
}
```

**switch** 语句必须遵循下面的规则：

- **switch** 语句中的 **expression** 是一个常量表达式，必须是一个整型或枚举类型。
- 在一个 switch 中可以有任意数量的 case 语句。每个 case 后跟一个要比较的值和一个冒号。
- case 的 **constant-expression** 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量。
- 当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 **break** 语句为止。
- 当遇到 **break** 语句时，switch 终止，控制流将跳转到 switch 语句后的下一行。
- 不是每一个 case 都需要包含 **break**。如果 case 语句不包含 **break**，控制流将会 *继续* 后续的 case，直到遇到 break 为止。
- 一个 **switch** 语句可以有一个可选的 **default** case，出现在 switch 的结尾。default case 可用于在上面所有 case 都不为真时执行一个任务。default case 中的 **break** 语句不是必需的。



------

**? : 运算符(三元运算符)**

我们已经在前面的章节中讲解了 **条件运算符 ? :**，可以用来替代 **if...else** 语句。它的一般形式如下：

```
Exp1 ? Exp2 : Exp3;
```

其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。

? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个表达式的值。

以下实例通过输入一个数字来判断它是否为奇数或偶数

```c
#include <stdio.h>
int main() {
  int number;
  printf("请输入一个数: ");
  scanf("%d", &number);
  (number % 2 == 0) ? printf("%d是偶数\n", number)
                    : printf("%d是奇数\n", number);
}

```



## 八、C 循环

有的时候，我们可能需要多次执行同一块代码。一般情况下，语句是按顺序执行的：函数中的第一个语句先执行，接着是第二个语句，依此类推。

编程语言提供了更为复杂执行路径的多种控制结构

------

**C while 循环**

只要给定的条件为真，C 语言中的 **while** 循环语句会重复执行一个目标语句。

C 语言中 **while** 循环的语法：

```c
while(condition)
{
   statement(s);
}
```

**condition** 可以是任意的表达式，当为任意非零值时都为 true。

当条件为 true 时执行循环。 当条件为 false 时，退出循环，程序流将继续执行紧接着循环的下一条语句。

------



**C for 循环**

**for** 循环允许您编写一个执行指定次数的循环控制结构。

C 语言中 **for** 循环的语法：

```c
for ( init; condition; increment )
{
   statement(s);
}
```

下面是 for 循环的控制流：

1. **init** 会首先被执行，且只会执行一次。这一步允许您声明并初始化任何循环控制变量。您也可以不在这里写任何语句，只要有一个分号出现即可。

2. 接下来，会判断 **condition**。如果为真，则执行循环主体。如果为假，则不执行循环主体，且控制流会跳转到紧接着 for 循环的下一条语句。

3. 在执行完 for 循环主体后，控制流会跳回上面的 **increment** 语句。该语句允许您更新循环控制变量。该语句可以留空，只要在条件后有一个分号出现即可。

4. 条件再次被判断。如果为真，则执行循环，这个过程会不断重复（循环主体，然后增加步值，再然后重新判断条件）。在条件变为假时，for 循环终止。

   

------

**C do...while 循环**

不像 **for** 和 **while** 循环，它们是在循环头部测试循环条件。

在 C 语言中，**do...while** 循环是在循环的尾部检查它的条件。

**do...while** 循环与 while 循环类似，但是 do...while 循环会确保至少执行一次循环。

## 

C 语言中 **do...while** 循环的语法：

```c
do
{
   statement(s);

}while( condition );
```

请注意，条件表达式出现在循环的尾部，所以循环中的 statement(s) 会在条件被测试之前至少执行一次。

如果条件为真，控制流会跳转回上面的 do，然后重新执行循环中的 statement(s)。这个过程会不断重复，直到给定条件变为假为止。



------

**循环控制语句**

循环控制语句改变你代码的执行顺序。通过它你可以实现代码的跳转。

C 提供了下列的循环控制语句。点击链接查看每个语句的细节。



**C break 语句**

C 语言中 **break** 语句有以下两种用法：

1. 当 **break** 语句出现在一个循环内时，循环会立即终止，且程序流将继续执行紧接着循环的下一条语句。
2. 它可用于终止 **switch** 语句中的一个 case。

如果您使用的是嵌套循环（即一个循环内嵌套另一个循环），break 语句会停止执行最内层的循环，然后开始执行该块之后的下一行代码。

C 语言中 **break** 语句的语法：

```
break;
```

![img](https://www.runoob.com/wp-content/uploads/2014/09/c-break-statement-works.jpg)

------

**C continue 语句**

C 语言中的 **continue** 语句有点像 **break** 语句。但它不是强制终止，continue 会跳过当前循环中的代码，强迫开始下一次循环。

对于 **for** 循环，**continue** 语句执行后自增语句仍然会执行。对于 **while** 和 **do...while** 循环，**continue** 语句重新执行条件判断语句。

## 

C 语言中 **continue** 语句的语法：

```
continue;
```

![img](https://www.runoob.com/wp-content/uploads/2014/09/c-continue-statement-works.jpg)



------

**C goto 语句**

**C 语言中的 goto 语句允许把控制无条件转移到同一函数内的被标记的语句。**

**注意：**在任何编程语言中，都不建议使用 goto 语句。因为它使得程序的控制流难以跟踪，使程序难以理解和难以修改。任何使用 goto 语句的程序可以改写成不需要使用 goto 语句的写法。

------

C 语言中 **goto** 语句的语法：

```
goto label;
..
.
label: statement;
```

在这里，**label** 可以是任何除 C 关键字以外的纯文本，它可以设置在 C 程序中 **goto** 语句的前面或者后面。

![img](https://www.runoob.com/wp-content/uploads/2015/01/goto.png)

**流程图**

![C goto 语句](https://www.runoob.com/wp-content/uploads/2014/09/c-goto-20200923-1.png)

**实例**

```c
#include <stdio.h>

int main() {
  int a = 10;
LOOP:
  do {
    if (a == 15) {
      a = a + 1;
      goto LOOP;
    }
    printf("a 的值是%d\n", a);
    a++;
  } while (a < 20);

  return 0;
}
```



## 九、C 函数

函数是一组一起执行一个任务的语句。每个 C 程序都至少有一个函数，即主函数 **main()** ，所有简单的程序都可以定义其他额外的函数。

您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。

函数**声明**告诉编译器函数的名称、返回类型和参数。函数**定义**提供了函数的实际主体。

C 标准库提供了大量的程序可以调用的内置函数。

例如，函数 **strcat()** 用来连接两个字符串，函数 **memcpy()** 用来复制内存到另一个位置。

函数还有很多叫法，比如方法、子例程或程序，等等。



**定义函数**

C 语言中的函数定义的一般形式如下：

```c
return_type function_name( parameter list )
{
   body of the function
}
```

在 C 语言中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：

- **返回类型：**一个函数可以返回一个值。**return_type** 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 **void**。
- **函数名称：**这是函数的实际名称。函数名和参数列表一起构成了函数签名。
- **参数：**参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。
- **函数主体：**函数主体包含一组定义函数执行任务的语句。

以下是 **max()** 函数的源代码。该函数有两个参数 num1 和 num2，会返回这两个数中较大的那个数：

```c
/* 函数返回两个数中较大的那个数 */
int max(int num1, int num2) 
{
   /* 局部变量声明 */
   int result;
 
   if (num1 > num2) {
      result = num1;
   } else {
      result = num2;
   }
   return result; 
}
```



------

**函数声明**

函数**声明**会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。

函数声明包括以下几个部分：

```c
return_type function_name( parameter list );
```

针对上面定义的函数 max()，以下是函数声明：

```c
int max(int num1, int num2);
```

在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明：

```c
int max(int, int);
```

当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。

在这种情况下，您应该在调用函数的文件顶部声明函数。



------

**调用函数**

创建 C 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。

当程序调用函数时，程序控制权会转移给被调用的函数。

被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。

调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。例如：

```c
#include <stdio.h>
 
/* 函数声明 */
int max(int num1, int num2);
 
int main ()
{
   /* 局部变量定义 */
   int a = 100;
   int b = 200;
   int ret;
 
   /* 调用函数来获取最大值 */
   ret = max(a, b);
 
   printf( "Max value is : %d\n", ret );
 
   return 0;
}
 
/* 函数返回两个数中较大的那个数 */
int max(int num1, int num2) 
{
   /* 局部变量声明 */
   int result;
 
   if (num1 > num2)
      result = num1;
   else
      result = num2;
 
   return result; 
}
```



------

**函数参数**

如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的**形式参数**。

形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。

当调用函数时，有两种向函数传递参数的方式：

**C 传值方式调用函数**

向函数传递参数的**传值调用**方法，把参数的实际值复制给函数的形式参数。

在这种情况下，修改函数内的形式参数不会影响实际参数。

默认情况下，C 语言使用*传值调用*方法来传递参数。一般来说，这意味着函数内的代码不会改变用于调用函数的实际参数。函数 **swap()** 定义如下：

```C
/* 函数定义 */
void swap(int x, int y)
{
   int temp;

   temp = x; /* 保存 x 的值 */
   x = y;    /* 把 y 赋值给 x */
   y = temp; /* 把 temp 赋值给 y */
  
   return;
}
```

现在，让我们通过传递实际参数来调用函数 **swap()**：

```C
#include <stdio.h>
 
/* 函数声明 */
void swap(int x, int y);
 
int main ()
{
   /* 局部变量定义 */
   int a = 100;
   int b = 200;
 
   printf("交换前，a 的值： %d\n", a );
   printf("交换前，b 的值： %d\n", b );
 
   /* 调用函数来交换值 */
   swap(a, b);
 
   printf("交换后，a 的值： %d\n", a );
   printf("交换后，b 的值： %d\n", b );
 
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```SH
交换前，a 的值： 100
交换前，b 的值： 200
交换后，a 的值： 100
交换后，b 的值： 200
```

------



**C 引用方式调用函数**

实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。

传递指针可以让多个函数访问指针所引用的对象，而不用把对象声明为全局可访问。

使用指针传值的swap()

```c
/*用于定义swap()*/
void swap(int *a, int *b) {
  int temp;
  temp = *a;
  *a = *b;
  *b = temp;
}
```

```c
#include <stdio.h>

void swap(int *a, int *b);

int main() {
  int a = 20;
  int b = 10;
  printf("交换前 a = %d\n", a);
  printf("交换前 b = %d\n", b);
  swap(&a, &b);
  printf("交换后 a = %d\n", a);
  printf("交换后 b = %d\n", b);
}
```

```
交换前 a = 20
交换前 b = 10
交换后 a = 10
交换后 b = 20
```



## 十、C 作用域规则

任何一种编程中，作用域是程序中定义的变量所存在的区域，超过该区域变量就不能被访问。C 语言中有三个地方可以声明变量：

1. 在函数或块内部的**局部**变量

2. 在所有函数外部的**全局**变量

3. 在**形式**参数的函数参数定义中

   

**局部变量**

在某个函数或块的内部声明的变量称为局部变量。它们只能被该函数或该代码块内部的语句使用。

局部变量在函数外部是不可知的。



**全局变量**

全局变量是定义在函数外部，通常是在程序的顶部。

全局变量在整个程序生命周期内都是有效的，在任意的函数内部能访问全局变量。

全局变量可以被任何函数访问。也就是说，全局变量在声明后整个程序中都是可用的。



**形式参数**

函数的参数，形式参数，被当作该函数内的局部变量，如果与全局变量同名它们会优先使用



**全局变量与局部变量在内存中的区别**：

- 全局变量保存在内存的全局存储区中，占用静态的存储单元；

- 局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。

  

**初始化局部变量和全局变量**

局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。

定义全局变量时，系统会自动对其初始化，如下所示：

| 数据类型 | 初始化默认值 |
| :------- | :----------- |
| int      | 0            |
| char     | '\0'         |
| float    | 0            |
| double   | 0            |
| pointer  | NULL         |

正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果，因为未初始化的变量会导致一些在内存位置中已经可用的垃圾值。



## 十一、c 数组

**声明数组**

在 C 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示：

```c
type arrayName [ arraySize ];
```

这叫做一维数组。**arraySize** 必须是一个大于零的整数常量，**type** 可以是任意有效的 C 数据类型。

例如，要声明一个类型为 double 的包含 10 个元素的数组 **balance**，声明语句如下：

```c
double balance[10];
```

现在 *balance* 是一个可用的数组，可以容纳 10 个类型为 double 的数字。



**初始化数组**

在 C 中，您可以逐个初始化数组，也可以使用一个初始化语句，如下所示：

```c
double balance[5] = {1000.0, 2.0, 3.4, 7.0, 50.0};
```

大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。

如果您省略掉了数组的大小，数组的大小则为初始化时元素的个数。因此，如果：

```c
double balance[] = {1000.0, 2.0, 3.4, 7.0, 50.0};
```

您将创建一个数组，它与前一个实例中所创建的数组是完全相同的。

下面是一个为数组中某个元素赋值的实例：

```c
balance[4] = 50.0;
```

上述的语句把数组中第五个元素的值赋为 50.0。所有的数组都是以 0 作为它们第一个元素的索引，也被称为基索引，数组的最后一个索引是数组的总大小减去 1。以下是上面所讨论的数组的的图形表示：

![数组表示](https://www.runoob.com/wp-content/uploads/2014/09/c-arrays-2021-1-18-4.png)

下图是一个长度为 **10** 的数组，第一个元素的索引值为 **0**，第九个元素 **runoob** 的索引值为 **8**:

![img](https://www.runoob.com/wp-content/uploads/2014/09/c-array-2021-01-18-2.png)





**访问数组元素**

数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如：

```c
double salary = balance[9];
```

上面的语句将把数组中第 10 个元素的值赋给 salary 变量。





​																**#######C 中数组详解########**

**C 多维数组**

C 语言支持多维数组。多维数组声明的一般形式如下：

```c
type name[size1][size2]...[sizeN];
```



**二维数组**

多维数组最简单的形式是二维数组。一个二维数组，在本质上，是一个一维数组的列表。声明一个 x 行 y 列的二维整型数组，形式如下：

```c
type arrayName [ x ][ y ];
```

其中，**type** 可以是任意有效的 C 数据类型，**arrayName** 是一个有效的 C 标识符。一个二维数组可以被认为是一个带有 x 行和 y 列的表格。下面是一个二维数组，包含 3 行和 4 列：

```c
int x[3][4];
```

![C 中的二维数组](https://www.runoob.com/wp-content/uploads/2014/09/two_dimensional_arrays.jpg)

因此，数组中的每个元素是使用形式为 a[ i , j ] 的元素名称来标识的，其中 a 是数组名称，i 和 j 是唯一标识 a 中每个元素的下标。



**C 传递数组给函数**

如果您想要在函数中传递一个一维数组作为参数，您必须以下面三种方式来声明函数形式参数，

**这三种声明方式的结果是一样的，因为每种方式都会告诉编译器将要接收一个整型指针**。

同样地，您也可以传递一个多维数组作为形式参数。

**方式 1**

形式参数是一个指针

注：数组的数组名实质上是一个指向数组索引0的指针

```c
void myFunction(int *param)
{
.
.
.
}
```

**方式 2**

形式参数是一个已定义大小的数组

```c
void myFunction(int param[10])
{
.
.
.
}
```

**方式 3**

形式参数是一个未定义大小的数组

```c
void myFunction(int param[])
{
.
.
.
}
```

**案例**（求数组平均值）

```c
#include <stdio.h>

/*函数声明*/
double getAverage(int arr[], int size);

int main() {
  int arr[] = {20, 33, 23, 554, 45};
  double result;
  result = getAverage(arr, 5);
  printf("result = %f", result);
}

double getAverage(int arr[], int size) {
  double sum;
  double avg;

  for (int i = 0; i < size; i++) {
    sum += arr[i];
  }
  avg = sum / size;

  return avg;
}
```



------

**C 从函数返回数组**

C 语言不允许返回一个完整的数组作为函数的参数。

但是，您可以通过指定不带索引的数组名来返回一个指向数组的指针。

如果您想要从函数返回一个一维数组，您必须声明一个返回指针的函数

```c
int * myFunction()
{
.
.
.
}
```

C 不支持在函数外返回局部变量的地址，除非定义局部变量为 **static** 变量。

现在，让我们来看下面的函数，它会生成 10 个随机数，并使用数组来返回它们，具体如下：

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int *getRandomArrary() {
  static int p[10];
  // 设置随机数种子
  srand((unsigned)time(NULL));
  for (int i = 0; i < 10; ++i) {
    p[i] = rand();
    printf("p[%d] = %d\n", i, p[i]);
  }
  return p;
}

int main() {
  int *q;
  q = getRandomArrary();
  for (int i = 0; i < 10; i++) {
    printf("*(q + %d) = %d\n", i, *(q + i));
  }
}
```

```
p[0] = 510666183
p[1] = 995822652
p[2] = 1681985341
p[3] = 1331542606
p[4] = 328482162
p[5] = 1872009421
p[6] = 614479334
p[7] = 1099595824
p[8] = 215876461
p[9] = 517040022
*(q + 0) = 510666183
*(q + 1) = 995822652
*(q + 2) = 1681985341
*(q + 3) = 1331542606
*(q + 4) = 328482162
*(q + 5) = 1872009421
*(q + 6) = 614479334
*(q + 7) = 1099595824
*(q + 8) = 215876461
*(q + 9) = 517040022
```



------

**C 指向数组的指针**

数组名是一个指向数组中第一个元素的常量指针。因此，在下面的声明中：

```
double balance[50];
```

**balance** 是一个指向 &balance[0] 的指针，即数组 balance 的第一个元素的地址。

因此，下面的程序片段把 **p** 赋值为 **balance** 的第一个元素的地址：

```c
double *p;
double balance[10];

p = balance;
```

使用数组名作为常量指针是合法的，反之亦然。因此，*(balance + 4) 是一种访问 balance[4] 数据的合法方式。

一旦您把第一个元素的地址存储在 p 中，您就可以使用 *p、*(p+1)、*(p+2) 等来访问数组元素。

下面的实例演示了上面讨论到的这些概念：

```c
#include <stdio.h>

int main() {
  double arr[] = {20.23, 12.22, 122.22, 34.44, 33.11};
  double *p;

  p = arr;
  /*使用指针访问数组*/
  for (int i = 0; i < 5; i++) {
    printf("*(p+%d) = %f\t", i, *(p + i));
    printf("arr[%d] = %f\n", i, arr[i]);
  }
}
```

```c
*(p+0) = 20.230000	arr[0] = 20.230000
*(p+1) = 12.220000	arr[1] = 12.220000
*(p+2) = 122.220000	arr[2] = 122.220000
*(p+3) = 34.440000	arr[3] = 34.440000
*(p+4) = 33.110000	arr[4] = 33.110000

```

p 是一个指向 double 型的指针，这意味着它可以存储一个 double 类型的变量。

一旦我们有了 p 中的地址，***p** 将给出存储在 p 中相应地址的值，正如上面实例中所演示的



## 十二、C enum(枚举)

枚举是 C 语言中的一种基本数据类型，它可以让数据更简洁，更易读。

枚举语法定义格式为：

```c
enum　枚举名　{枚举元素1,枚举元素2,……};
```

接下来我们举个例子，比如：一星期有 7 天，如果不用枚举，我们需要使用 #define 来为每个整数定义一个别名：

```c
#define MON  1
#define TUE  2
#define WED  3
#define THU  4
#define FRI  5
#define SAT  6
#define SUN  7
```

这个看起来代码量就比较多，接下来我们看看使用枚举的方式：

```c
enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
};
```

这样看起来是不是更简洁了。

**注意：**

第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。我们在这个实例中把第一个枚举成员的值定义为 1，第二个就为 2，以此类推。

没有指定值的枚举元素，其值为前一元素加 1。也就说如果第一个枚举成员未被赋值那他默认为0, 第二个赋值为3, 第三个未赋值那么第三个值为4。



------

**枚举变量的定义**

**1、先定义枚举类型，再定义枚举变量**

```c
enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
};
enum DAY day;
```

**2、定义枚举类型的同时定义枚举变量**

```c
enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
} day;
```

**3、省略枚举名称，直接定义枚举变量**

```c
enum
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
} day;
```

**案例**

```c
#include <stdio.h>

enum DAY { MON = 1, TUE, WED, THU, FRI, SAT, SUN };

int main() {
  enum DAY day;
  day = WED;
  printf("day = %d\n", day);
  return 0;
}

```



------

**枚举使用**

**遍历**

在C 语言中，枚举类型是被当做 int 或者 unsigned int 类型来处理的，所以按照 C 语言规范是没有办法遍历枚举类型的。

如果必须遍历枚举，枚举类型必须连续是可以实现有条件的遍历。

```c
#include <stdio.h>

enum DAY { MON = 1, TUE, WED, THU, FRI, SAT, SUN };

int main() {
  enum DAY day;
  enum DAY day2;
  day = WED;
  printf("day = %d\n", day);
  for (day2 = MON; day2 < SUN; day2++) {
    printf("day2 值为 %d\n", day2);
  }
  return 0;
}

```

**枚举在 switch 中的使用**

枚举类型不连续的枚举无法遍历，但是可以使用switch

```c
#include <stdio.h>

enum COLOR { RDE = 1, GREEN, BLUR };
int main() {
  enum COLOR myfaveratecolor;
  printf("1.red 2.green 3.blur");
  printf("请输入：");
  scanf("%u", &myfaveratecolor);
  switch (myfaveratecolor) {
  case RDE:
    printf("红色");
    break;
  case GREEN:
    printf("绿色");
    break;
  case BLUR:
    printf("蓝色");
    break;
  }
}

```



**将整数转换为枚举**

```c
#include <stdio.h>
#include <stdlib.h>
 
int main()
{
 
    enum day
    {
        saturday,
        sunday,
        monday,
        tuesday,
        wednesday,
        thursday,
        friday
    } workday;
 
    int a = 1;
    enum day weekend;
    weekend = ( enum day ) a;  //类型转换
    //weekend = a; //错误
    printf("weekend:%d",weekend);
    return 0;
}
```

```
weekend:1
```



## 十三、C 指针

每一个变量都有一个内存位置，每一个内存位置都定义了可使用 **&** 运算符访问的地址，它表示了在内存中的一个地址。

```c
#include <stdio.h>
int main() {
  int a = 1;
  int *p;
  p = &a;
  printf("a %p\n", &a);
  printf("p %p\n", p);
}

```

```
a 0x7ffc0ab8a984
p 0x7ffc0ab8a984
```

![img](https://www.runoob.com/wp-content/uploads/2014/09/c-pointer.png)



**什么是指针？**

指针也就是内存地址，指针变量是用来存放内存地址的变量。

就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为

```
type *var_name;
```

在这里，**type** 是指针的基类型，它必须是一个有效的 C 数据类型，**var_name** 是指针变量的名称。

用来声明指针的星号 ***** 与乘法中使用的星号是相同的。

但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明：

```c
int    *ip;    /* 一个整型的指针 */
double *dp;    /* 一个 double 型的指针 */
float  *fp;    /* 一个浮点型的指针 */
char   *ch;    /* 一个字符型的指针 */
```

所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制数。

（printf 打印指针地址使用 占位符 %p）

不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。

**注：**

在64系统中，一个指针占8字节;

在32系统中，一个指针占4字节;



**指针的基本操作**

使用指针时会频繁进行以下几个操作：

定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。

这些是通过使用一元运算符 ***** 来返回位于操作数所指定地址的变量的值。

```c
#include <stdio.h>

int main() {
  int a = 10;
  int *p;
  p = &a;
  printf("a %p\n", &a);
  printf("p %p\n", p);
  printf("*p %d\n", *p);
}
```

```
a 0x7ffc993fb694
p 0x7ffc993fb694
*p 10
```



**C 中的 NULL 指针**

在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。

赋为 NULL 值的指针被称为**空**指针。

NULL 指针是一个定义在标准库中的值为零的常量。请看下面的程序：

```c
#include <stdio.h>
 
int main ()
{
   int  *ptr = NULL;
 
   printf("ptr 的地址是 %p\n", ptr  );
 
   return 0;
}
```

```c
ptr 的地址是 0x0
```

内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。

但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。



​																		**######c指针详解#####**

**C 指针的算术运算**

C 指针是一个用数值表示的地址。

因此，您可以对指针执行算术运算。可以对指针进行四种算术运算：++、--、+、-。

假设 **ptr** 是一个指向地址 1000 的整型指针（int *ptr），是一个 32 位的整数，让我们对该指针执行下列的算术运算：

```c
ptr++
```

在执行完上述的运算之后，**ptr** 将指向位置 1004，因为 ptr 每增加一次，它都将指向下一个整数位置，即当前位置往后移 4 字节。这个运算会在不影响内存位置中实际值的情况下，移动指针到下一个内存位置。

如果 **ptr** 指向一个地址为 1000 的字符，上面的运算会导致指针指向位置 1001，因为下一个字符位置是在 1001。

**注：**

- 指针的每一次递增，它其实会指向下一个元素的存储单元。
- 指针的每一次递减，它都会指向前一个元素的存储单元。
- 指针在递增和递减时跳跃的字节数取决于指针所指向变量数据类型长度，比如 int 就是 4 个字节。



------

**递增一个指针**

```c
#include <stdio.h>

const int MAX = 3;

int main() {
  int arr[] = {23, 123, 1322};

  int *p;

  p = arr;

  for (int i = 0; i < MAX; i++) {
    printf("数组arr第%d个数是：%d\n", i + 1, *(p + i));
    printf("数组arr第%d数的储存地址是：%p\n", i + 1, (p + i));
  }
}
```

```c
//或者
#include <stdio.h>

const int MAX = 3;

int main() {
  int arr[] = {23, 123, 1322};

  int *p;

  p = arr;

  printf("%p\n", p);
  for (int i = 0; i < MAX; i++) {
    printf("数组arr第%d个数是：%d\n", i + 1, *p);
    printf("数组arr第%d数的储存地址是：%p\n", i + 1, p);
    p++;
  }
}
```

```c
数组arr第1个数是：23
数组arr第1数的储存地址是：0x7fffa80ccf64
数组arr第2个数是：123
数组arr第2数的储存地址是：0x7fffa80ccf68
数组arr第3个数是：1322
数组arr第3数的储存地址是：0x7fffa80ccf6c
```



------

**指针的比较**

指针可以用关系运算符进行比较，如 ==、< 和 >。

如果 p1 和 p2 指向两个相关的变量，比如同一个数组中的不同元素，则可对 p1 和 p2 进行大小比较。

```c
#include <stdio.h>

const int MAX = 3;

int main() {
  int arr[] = {23, 123, 1322};

  int *p;

  p = arr;

  printf("%p\n", p);
  for (; p <= &arr[MAX - 1]; p++) {
    printf("%d\n", *p);
  }
}
```



------

**指针数组**

**定义**

```
type *Name[Length]
```

本质上是存储16进制地址值的数组

```c
#include <stdio.h>

const int MAX = 3;

int main() {
  int arr[] = {23, 123, 1322};

  int *p[MAX];

  for (int i = 0; i < MAX; i++) {
    p[i] = &arr[i];
  }
  for (int j = 0; j < MAX; j++) {
    printf("指针数组p[%d] = %d\n", j, *p[j]);
  }
}
```

```
指针数组p[0] = 23
指针数组p[1] = 123
指针数组p[2] = 1322
```



------

**C 指向指针的指针**

指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。

通常，一个指针包含一个变量的地址。当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。

![C 中指向指针的指针](https://www.runoob.com/wp-content/uploads/2014/09/pointer_to_pointer.jpg)

一个指向指针的指针变量必须如下声明，即在变量名前放置两个星号。

例如，下面声明了一个指向 int 类型指针的指针：

```
int **var;
```

当一个目标值被一个指针间接指向到另一个指针时，访问这个值需要使用两个星号运算符，如下面实例所示：

![img](https://www.runoob.com/wp-content/uploads/2014/09/c-pointerxxxxx.png)

**案例**

```c
#include <stdio.h>

int main() {
  int a = 2022;
  int *p, **q;
  p = &a;
  q = &p;

  printf("p value : %d\n", *p);
  printf("p address : %p\n", p);

  printf("q value : %p\n", *q);
  printf("q address : %p\n", q);
  printf("q realValue : %d\n", **q);
}
```

```
p value : 2022
p address : 0x7ffe23d11cd4
q value : 0x7ffe23d11cd4
q address : 0x7ffe23d11cc8
q realValue : 2022
```



------

**C 传递指针给函数**

C 语言允许您传递指针给函数，只需要简单地声明函数参数为指针类型即可。

下面的实例中，我们传递一个无符号的 long 型指针给函数，并在函数内改变这个值：

```c
#include <stdio.h>
#include <time.h>

void getSeconds(unsigned long *p);

int main() {
  unsigned long sec;

  getSeconds(&sec);

  printf("Number value is : %ld\n", sec);
}

void getSeconds(unsigned long *p) {
  *p = time(NULL);
  return;
}
```

```c
Number value is : 1665835923
```

**能接受指针作为参数的函数，也能接受数组作为参数**（还是因为数组名的指针指向数组第0个元素）

```c
#include <stdio.h>

double getAvg(int *arr, int size);

int main() {
  int arr[] = {21313, 13231, 1231, 3443, 1212};
  int size = 5;
  double AVG = getAvg(arr, size);
  printf("%f\n", AVG);
}

double getAvg(int *arr, int size) {
  double sum = 0;
  for (int i = 0; i < size; i++) {
    sum += arr[i];
  }
  double AVG = sum / size;
  return AVG;
}
```



## 十四、函数指针与回调函数

**函数指针**

函数指针是指向函数的指针变量。

通常我们说的指针变量是指向一个整型、字符型或数组等变量，而函数指针是指向函数。

函数指针可以像一般函数一样，用于调用函数、传递参数。

函数指针变量的声明：

```c
int (*fun_ptr)(int,int); // 声明一个指向同样参数、返回值的函数指针类型
```

**案例**（比较三数之和）

```c
#include <stdio.h>

int MAX(int a, int b) {
  if (a > b) {
    return a;
  } else {
    return b;
  }
}

int main() {
  int a, b, c, max;
  int (*p)(int, int) = &MAX;
  printf("ENTER THREE NUMBER : ");
  scanf("%d %d %d", &a, &b, &c);
  max = p(p(a, b), c);
  printf("THE BIGGEST NUMBER IS : %d", max);
}
```

```c
ENTER THREE NUMBER : 23 233 34
THE BIGGEST NUMBER IS : 233
```



**回调函数**

函数指针作为某个函数的参数

函数指针变量可以作为某个函数的参数来使用

回调函数就是一个通过函数指针调用的函数。

简单讲：回调函数是由别人的函数执行时调用你实现的函数。

```c
#include <stdio.h>
#include <stdlib.h>

int getRandNumber(void) { return rand(); }

void functionBack(int *arr, int size, int (*backFun)(void)) {
  for (int i = 0; i < size; i++) {
    arr[i] = backFun();
  }
  return;
}

int main() {

  int arr[10];
  functionBack(arr, 10, getRandNumber);
  for (int i = 0; i < 10; i++) {
    printf("arr[%d] : %d\n", i, arr[i]);
  }
  printf("A NUMBER : %d", getRandNumber());
  return 0;
}
```

```c
arr[0] : 1804289383
arr[1] : 846930886
arr[2] : 1681692777
arr[3] : 1714636915
arr[4] : 1957747793
arr[5] : 424238335
arr[6] : 719885386
arr[7] : 1649760492
arr[8] : 596516649
arr[9] : 1189641421
A NUMBER : 1025202362
```



## 十五、字符串

在c语言中，字符串实际上是一个以 \0 （空字符）结尾的一维字符数组，因此  \0 标志着一个字符串结束。

**空字符（Null Character）**又称结束符，缩写为 NUL，是一个数值为 0 的控制字符，\ 是转义字符，

标识  \0 不是字符 0 ，而是空字符。

![C/C++ 中的字符串表示](https://www.runoob.com/wp-content/uploads/2014/09/c-strings-2020-12-21.png)

其实，您不需要把 **null** 字符放在字符串常量的末尾。C 编译器会在初始化数组时，自动把 **\0** 放在字符串的末尾。

**初始化字符串**（Hello）

1.方法一

```c
char str[6] {'H','e','l','l','o','\0'};
```

2.方法二

```c
char str[] = "Hello";
```

**操作字符串的函数**

| 方法名          | 用法                                                         |
| --------------- | ------------------------------------------------------------ |
| strcpy(s1, s2); | 复制字符串 s2 到字符串 s1。                                  |
| strcat(s1, s2); | 连接字符串 s2 到字符串 s1 的末尾。                           |
| strlen(s1);     | 返回字符串 s1 的长度。                                       |
| strcmp(s1, s2); | 如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回小于 0；如果 s1>s2 则返回大于 0。 |
| strchr(s1, ch); | 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。   |
| strstr(s1, s2); | 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 |

```c
#include <stdio.h>
#include <string.h>

#define MAXLENGTH 100

int main() {

  char str1[] = "Hello";
  char str2[] = "World";
  char str3[MAXLENGTH];

  /*复制字符串*/
  printf("str3 : %s\n", str3);
  strcpy(str3, str2);
  printf("str3 : %s\n", str3);

  /*连接字符串*/
  strcat(str1, str2);
  printf("%s\n", str1);
  /*返回字符串长度*/
  int a = strlen(str1);
  printf("%d\n", a);

  /*如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回小于 0；如果 s1>s2
   * 则返回大于 0。*/
  int b = strcmp(str2, str3);
  printf("%d\n", b);

  /*返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。*/
  char *p = strchr(str1, 'H');
  printf("p = %p\n", p);
  printf("*p = %c\n", *p);

  /*返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。*/
  char *q = strstr(str1, "llo");
  /*该函数支持使用字符串变量或字符串作为参数*/
  printf("q = %p\n", q);
  printf("*q = %c\n", *q);
  return 0;
}
```

## 十六、C 结构体

C 数组允许定义可存储相同类型数据项的变量，**结构**是 C 编程中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。

**定义结构**

为了定义结构，您必须使用 **struct** 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：

```c
struct tag { 
    member-list
    member-list 
    member-list  
    ...
} variable-list ;
```

**tag** 是结构体标签。

**member-list** 是标准的变量定义，比如 int i; 或者 float f，或者其他有效的变量定义。

**variable-list** 结构变量，定义在结构的末尾，最后一个分号之前，您可以指定一个或多个结构变量。下面是声明 Book 结构的方式：

```c
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
} book;
```



```c
//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c
//同时又声明了结构体变量s1
//这个结构体并没有标明其标签
struct 
{
    int a;
    char b;
    double c;
} s1;
 
//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c
//结构体的标签被命名为SIMPLE,没有声明变量
struct SIMPLE
{
    int a;
    char b;
    double c;
};
//用SIMPLE标签的结构体，另外声明了变量t1、t2、t3
struct SIMPLE t1, t2[20], *t3;
 
//也可以用typedef创建新类型
typedef struct
{
    int a;
    char b;
    double c; 
} Simple2;

//现在可以用Simple2作为类型声明新的结构体变量
Simple2 u1, u2[20], *u3;
```



**结构体变量的初始化**

```c
#include <stdio.h>

/*方法一*/
struct Books {
  int bookId;
  char bookName[50];
  char bookAuthor[50];
};

/*方法二*/
typedef struct Goods {
  int value;
  char goodsName[50];
} Goods;

int main() {
  /*方法一*/
  struct Books book1 = {32, "人与自然", "大卫"};

  /*方法二*/
  Goods goods1 = {123, "牛奶"};

  printf("%d\n", book1.bookId);
  printf("%s\n", book1.bookName);
  printf("%s\n", book1.bookAuthor);

  printf("%d\n", goods1.value);
  printf("%s\n", goods1.goodsName);

  return 0;
}
```

**访问结构成员**

```c
#include <stdio.h>

typedef struct Goods {
  int value;
  char goodsName[50];
} Goods;

int main() {
  Goods goods;

  printf("Goods value:");
  scanf("%d", &goods.value);

  printf("Goods goodsName:");
  scanf("%s", goods.goodsName);

  printf("Goods value: %d\n", goods.value);
  printf("Goods goodsName: %s\n", goods.goodsName);
}
```

```sh
Goods value:43342
Goods goodsName:放大房价是
Goods value: 43342
Goods goodsName: 放大房价是
```

结构作为函数参数

您可以把结构作为函数参数，传参方式与其他类型的变量或指针类似。您可以使用上面实例中的方式来访问结构变量：

```c
/*************************************************************************
    > File Name: 03-结构体作为函数参数.c
    > Author: Aerlany
    > Mail: 1243535201@qq.com
    > Created Time: Fri 28 Oct 2022 04:17:43 PM CST
 ************************************************************************/

#include <stdio.h>

#define MAXLENGTH 100
typedef struct Book {
  int BookId;
  char BookName[MAXLENGTH];
} Book;

void PrintBookItem(Book Book1);

int main() {
  Book Book1;
  printf("BookId = ");
  scanf("%d", &Book1.BookId);
  printf("BookName = ");
  scanf("%s", Book1.BookName);

  PrintBookItem(Book1);
}

void PrintBookItem(Book Book1) {
  printf("BookId : %d\n", Book1.BookId);

  printf("BookName : %s\n", Book1.BookName);
}
```

指向结构的指针

您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示：

```c
struct Book{
	int id;
	char BookName[100];
}

struct Book *book1;
```

**案例**

```c
#include <stdio.h>
#include <string.h>

#define MAXLENGTH 100

typedef struct Book {
  int id;
  char bookName[MAXLENGTH];
} Book;

void PrintBookItem(Book *Book1) {
  printf("Book id: %d\n", Book1->id);
  printf("Book bookName: %s\n", Book1->bookName);
}

int main() {
  Book Book1;

  printf("BookId = ");
  scanf("%d", &Book1.id);
  printf("BookName = ");
  scanf("%s", Book1.bookName);

  PrintBookItem(&Book1);
  return 0;
}
```

```sh
BookId = 1231
BookName = 三国演义
Book id: 1231
Book bookName: 三国演义
```



## 十七、共用体

**共用体**是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。

**定义共用体**

为了定义共用体，您必须使用 **union** 语句，方式与定义结构类似。union 语句定义了一个新的数据类型，带有多个成员。union 语句的格式如下：

```c
union [union tag]
{
   member definition;
   member definition;
   ...
   member definition;
} [one or more union variables];
```

**union tag** 是可选的，每个 member definition 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在共用体定义的末尾，最后一个分号之前，您可以指定一个或多个共用体变量，这是可选的。下面定义一个名为 Data 的共用体类型，有三个成员 i、f 和 str：

```c
union Data
{
   int i;
   float f;
   char  str[20];
} data;
```

现在，**Data** 类型的变量可以存储一个整数、一个浮点数，或者一个字符串。这意味着一个变量（相同的内存位置）可以存储多个多种类型的数据。您可以根据需要在一个共用体内使用任何内置的或者用户自定义的数据类型。

共用体占用的内存应足够存储共用体中最大的成员。

**案例**

```c
/*************************************************************************
    > File Name: 01-共用体大小.c
    > Author: Aerlany
    > Mail: 1243535201@qq.com
    > Created Time: Sun 06 Nov 2022 09:33:33 PM CST
 ************************************************************************/

#include <stdio.h>

union Data {
  int num;
  char String[100];
  float f;
};

int main() {
  union Data data;
  printf("The Size Of Union: %d\n", sizeof(data));

  return 0;
}
```

```sh
The Size Of Union: 100
```

**访问共用体成员**

为了访问共用体的成员，我们使用**成员访问运算符（.）**。成员访问运算符是共用体变量名称和我们要访问的共用体成员之间的一个句号。您可以使用 **union** 关键字来定义共用体类型的变量。

```c
/*************************************************************************
    > File Name: 02-访问共用体成员.c
    > Author: Aerlany
    > Mail: 1243535201@qq.com
    > Created Time: Sun 06 Nov 2022 09:40:41 PM CST
 ************************************************************************/

#include <stdio.h>
#include <string.h>

typedef union Data {
  int num;
  char String[100];
  float f;
} Data;

int main() {
  Data data;
  data.num = 13222;
  printf("data.num: %d\n", data.num);

  data.f = 3.14;
  printf("data.f: %f\n", data.f);

  strcpy(data.String, "HelloWorld");
  printf("data.String : %s\n", data.String);

  return 0;
}
```

```c
data.num: 13222
data.f: 3.140000
data.String : HelloWorld
```

**注意:**

共用体每次只能存储一个成员,同时对多个成员赋值只有最后一个有效;

```c
/*************************************************************************
    > File Name: 03-访问共用体成员.c
    > Author: Aerlany
    > Mail: 1243535201@qq.com
    > Created Time: Sun 06 Nov 2022 09:40:41 PM CST
 ************************************************************************/

#include <stdio.h>
#include <string.h>

typedef union Data {
  int num;
  char String[100];
  float f;
} Data;

int main() {
  Data data;

  data.num = 13222;
  data.f = 3.14;
  strcpy(data.String, "HelloWorld");

  printf("data.num: %d\n", data.num);
  printf("data.f: %f\n", data.f);
  printf("data.String : %s\n", data.String);

  return 0;
}
```

```c
data.num: 1819043144
data.f: 1143139122437582505939828736.000000
data.String : HelloWorld
```



## 十八、C typedef

C 语言提供了 **typedef** 关键字，您可以使用它来为类型取一个新的名字。

```c
typedef unsigned char BYTE;
```

您也可以使用 **typedef** 来为用户自定义的数据类型取一个新的名字。

```c
#include <stdio.h>
#include <string.h>
 
typedef struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
} Book;
 
int main( )
{
   Book book;
 
   strcpy( book.title, "C 教程");
   strcpy( book.author, "Runoob"); 
   strcpy( book.subject, "编程语言");
   book.book_id = 12345;
 
   printf( "书标题 : %s\n", book.title);
   printf( "书作者 : %s\n", book.author);
   printf( "书类目 : %s\n", book.subject);
   printf( "书 ID : %d\n", book.book_id);
 
   return 0;
}
```

```sh
书标题 : C 教程
书作者 : Runoob
书类目 : 编程语言
书 ID : 12345
```



------

**typedef vs #define**

**#define** 是 C 指令，用于为各种数据类型定义别名，与 **typedef** 类似，但是它们有以下几点不同：

- **typedef** 仅限于为类型定义符号名称，**#define** 不仅可以为类型定义别名，也能为数值定义别名，比如您可以定义 1 为 ONE。
- **typedef** 是由编译器执行解释的，**#define** 语句是由预编译器进行处理的。

下面是 #define 的最简单的用法：

```c
#include <stdio.h>
 
#define TRUE  1
#define FALSE 0
 
int main( )
{
   printf( "TRUE 的值: %d\n", TRUE);
   printf( "FALSE 的值: %d\n", FALSE);
 
   return 0;
}
```

```sh
TRUE 的值: 1
FALSE 的值: 0
```



## 十九、C 输入 & 输出

当我们提到**输入**时，这意味着要向程序填充一些数据。输入可以是以文件的形式或从命令行中进行。

当我们提到**输出**时，这意味着要在屏幕上、打印机上或任意文件中显示一些数据。



**标准文件**

C 语言把所有的设备都当作文件。所以设备（比如显示器）被处理的方式与文件相同。以下三个文件会在程序执行时自动打开，以便访问键盘和屏幕。

| 标准文件 | 文件指针 | 设备     |
| :------- | :------- | :------- |
| 标准输入 | stdin    | 键盘     |
| 标准输出 | stdout   | 屏幕     |
| 标准错误 | stderr   | 您的屏幕 |

文件指针是访问文件的方式，本节将讲解如何从键盘上读取值以及如何把结果输出到屏幕上。



**C 语言中的 I/O (输入/输出) 通常使用 printf() 和 scanf() 两个函数。**

scanf() 函数用于从标准输入（键盘）读取并格式化， printf() 函数发送格式化输出到标准输出（屏幕）。

**int scanf(const char \*format, ...)** 函数从标准输入流 **stdin** 读取输入，并根据提供的 **format** 来浏览输入。

**int printf(const char \*format, ...)** 函数把输出写入到标准输出流 **stdout** ，并根据提供的格式产生输出。

**format** 可以是一个简单的常量字符串，但是您可以分别指定 %s、%d、%c、%f 等来输出或读取字符串、整数、字符或浮点数

```c
/*************************************************************************
    > File Name: 03-printf_scanf.c
    > Author: Aerlany
    > Mail: 1243535201@qq.com
    > Created Time: Mon 07 Nov 2022 05:07:24 PM CST
 ************************************************************************/

#include <stdio.h>

int main() {
  char str[100];
  int a;

  printf("Enter a Sentence and a Number, Separate them with a space:");
  scanf("%s %d", str, &a);

  printf("Sentence is : %s\n", str);
  printf("Number is : %d\n", a);

  return 0;
}
```



------

**getchar() & putchar() 函数**

**int getchar(void)** 函数从屏幕读取下一个可用的字符，并把它返回为一个整数。

这个函数在同一个时间内只会读取一个单一的字符。您可以在循环内使用这个方法，以便从屏幕上读取多个字符。



**int putchar(int c)** 函数把字符输出到屏幕上，并返回相同的字符。

这个函数在同一个时间内只会输出一个单一的字符。您可以在循环内使用这个方法，以便在屏幕上输出多个字符。

```c
/*************************************************************************
    > File Name: 01-getchar.c
    > Author: Aerlany
    > Mail: 1243535201@qq.com
    > Created Time: Mon 07 Nov 2022 04:50:40 PM CST
 ************************************************************************/

#include <stdio.h>

int main() {
  int c;
  printf("Enter a Num : ");
  c = getchar();

  printf("\nc :");
  putchar(c);
  return 0;
}
```

```c
Enter a Num : r

c :r
```



------

**gets() & puts() 函数**

**char \*gets(char \*s)** 函数从 **stdin** 读取一行到 **s** 所指向的缓冲区，直到一个终止符或 EOF。

**int puts(const char \*s)** 函数把字符串 s 和一个尾随的换行符写入到 **stdout**。

```c
/*************************************************************************
    > File Name: 02-gets_puts.c
    > Author: Aerlany
    > Mail: 1243535201@qq.com
    > Created Time: Mon 07 Nov 2022 04:58:44 PM CST
 ************************************************************************/

#include <stdio.h>

int main() {
  char str[100];
  printf("Enter a sentence:");
  gets(str);

  printf("\n You Enter :");
  puts(str);
  return 0;
}
```

```c
02-gets_puts.c:(.text+0x24): warning: the `gets' function is dangerous and should not be used.
Enter a sentence:Hello world

 You Enter :Hello world
```









